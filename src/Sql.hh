#pragma once
#include<iostream>
#include<string>
#include<vector>
#include<stdarg.h>
#include"macros.hh"
namespace orm { enum class Sort { ASC, DESC }; static const char* SORT[2] = { "", " DESC" }; template<typename T> class Table; template<typename T> struct Query { Query<T>(Query<T> const&) = delete; Query<T>& operator=(Query<T>&&) = delete; Query<T>(Query<T>&&) = default; Query<T>& operator=(Query<T> const&) = delete; template<typename F, typename... K> Query<T>(F& f, K&...k) : _("SELECT ") { static_assert(is_text<std::decay_t<F>>::value); _ += f.c_str(); if constexpr (sizeof...(K) > 0) { static_assert(is_text<std::decay_t<K>...>::value); Exp{ (fields(_, std::forward<K>(k)), 0)... }; } _ += " FROM "; _ += T::_name; _ += T::_alias; fk = &f; } ~Query<T>() { fk = nullptr; } Query<T>& size(uint8_t size) { size_ = size; return *this; } Query<T>& page(size_t page) { page_ = page < 1 ? 1 : page; return *this; } template<unsigned short I> Query<T>& where(const text<I>& v_) { _ += " WHERE "; _ += v_.c_str(); return *this; } template<typename V> auto inline Get(const Sort& ord = Sort::ASC) { _ += " ORDER BY "; _ += fk->c_str(); _ += SORT[static_cast<char>(ord)]; _ += " LIMIT "; _ += std::to_string(size_); _ += " OFFSET "; _ += std::to_string((page_ - 1) * size_); return D.conn()(_).template r__<V>(); } private: uint8_t size_{ 10 }; size_t page_{ 1 }; std::string _; const text<63>* fk; inline void fields(std::string& os, const text<0x3f>& v_); }; template<typename T> void Query<T>::fields(std::string& os, const text<0x3f>& v_) { os.push_back(','); os += v_.c_str(); }; template<typename T> struct Sql { friend class Table<T>; Sql<T>() : _(T::_ios) { _.reserve(0x1ff); __.reserve(0x5f); _ += " FROM "; _ += T::_name; _ += T::_alias; } ~Sql<T>() {} inline Sql<T>& size(uint8_t size); inline Sql<T>& page(size_t page); inline Sql<T>& orderBy(const text<0x3f>& col, const Sort& ord = Sort::ASC); template<unsigned short I> inline Sql<T>& where(const text<I>& str); std::vector<T> GetArr(const Sort& ord = Sort::ASC)noexcept; inline T GetOne()noexcept; template<typename U> T GetOne(U* u)noexcept { _ += " LIMIT 1"; std::string sql(_); this->clear(); return D.conn()(sql).template find<T>(u); }; template<typename U> std::vector<T> GetArr(std::vector<U>* vu, const Sort& ord = Sort::ASC)noexcept { _ += " ORDER BY "; __ += T::_alias; __.push_back('.'); if constexpr (pgsqL) { __.push_back(34); __ += T::$[0]; __.push_back(34); } else { __.push_back(96); __ += T::$[0]; __.push_back(96); } _ += __; _ += SORT[static_cast<char>(ord)]; _ += " LIMIT "; _ += std::to_string(size_); _ += " OFFSET "; _ += std::to_string((page_ - 1) * size_); std::string sql(_); this->clear(); return D.conn()(sql).template find<T>(vu); }; json GetJson() { std::cout << _; this->clear(); return json{ "Only stars, flowers and applause can satisfy my arrogance and greatness" }; }; inline decltype(D)::connection_type DB(); static void InsertArr(std::vector<T>* t); template<typename U> inline Sql<T>& innerJoin(); template<typename U, unsigned short I> inline Sql<T>& innerJoin(const text<I>& v_); template<typename U> inline Sql<T>& leftJoin(); template<typename U, typename V> inline Sql<T>& leftJoin(); private: uint8_t size_{ 10 }; size_t page_{ 1 }; std::string _, __; bool ___{ true }; std::string choose(const char* c) { std::string s; const char* a = T::_alias.data(); s += a; if (*c == '(') { } else { } return s; } inline void clear() { _ = T::_ios; _ += " FROM "; _ += T::_name; _ += T::_alias; size_ = 10; __.clear(); page_ = 1; ___ = true; } template<typename V> inline void F(const std::string_view& c) { _ += V::_alias; _.push_back('.'); if constexpr (pgsqL) { _.push_back('"'); _ += c; _.push_back('"'); } else { _.push_back('`'); _ += c; _.push_back('`'); } }; template<typename U> inline void f(const std::string_view& c) { _.push_back(','); _ += U::_alias; _.push_back('.'); if constexpr (pgsqL) { _.push_back('"'); _ += c; _.push_back('"'); } else { _.push_back('`'); _ += c; _.push_back('`'); } _ += U::_as_alia; _ += c; }; }; template<typename T> Sql<T>& Sql<T>::size(uint8_t size) { size_ = size; return *this; } template<typename T> Sql<T>& Sql<T>::page(size_t page) { page_ = page < 1 ? 1 : page; return *this; } template<typename T> Sql<T>& Sql<T>::orderBy(const text<0x3f>& col, const Sort& ord) { __ += col.c_str(); __ += SORT[static_cast<char>(ord)]; __.push_back(','); return *this; } template<typename T> template<unsigned short I> Sql<T>& Sql<T>::where(const text<I>& v_) { _ += " WHERE "; _ += v_.c_str(); return *this; } template<typename T> std::vector<T> Sql<T>::GetArr(const Sort& ord)noexcept { _ += " ORDER BY "; __ += T::_alias; __.push_back('.'); if constexpr (pgsqL) { __.push_back(34); __ += T::$[0]; __.push_back(34); } else { __.push_back(96); __ += T::$[0]; __.push_back(96); } _ += __; _ += SORT[static_cast<char>(ord)]; _ += " LIMIT "; _ += std::to_string(size_); _ += " OFFSET "; _ += std::to_string((page_ - 1) * size_); std::string sql(_); this->clear(); return D.conn()(sql).template findArr<T>(); } template<typename T> T Sql<T>::GetOne()noexcept { _ += " LIMIT 1"; std::string sql(_); this->clear(); return D.conn()(sql).template find<T>(); } template<typename T> decltype(D)::connection_type Sql<T>::DB() { ___ = true; return D.conn(); } template<typename T> void Sql<T>::InsertArr(std::vector<T>* input) { int8_t i = 0; std::ostringstream os, ov; ov << "VALUES "; os << "INSERT INTO " << T::_name << '('; for (; i < T::_len; ++i) { if (!(T::_tc[i] & (TC::PRIMARY_KEY | TC::AUTO_INCREMENT))) { if constexpr (pgsqL) { os << '"' << T::$[i] << "\","; } else { os << T::$[i] << ','; } } } os.seekp(-1, os.cur); for (auto o : *input) { i = -1; ov << '('; ForEachField(dynamic_cast<T*>(&o), [&i, &os, &ov](auto& t) { if (!(T::_tc[++i] & (TC::PRIMARY_KEY | TC::AUTO_INCREMENT))) { const char* def = T::_def[i]; using Y = std::remove_reference_t<decltype(t)>; if constexpr (std::is_same<bool, Y>::value) { if constexpr (pgsqL) { ov << (t ? "true" : "false") << ','; } else { ov << t << ','; } } else if constexpr (std::is_fundamental<Y>::value) { if (!*((char*)&t) && def[0]) { ov << def << ','; } else { ov << t << ','; } } else if constexpr (std::is_same<tm, Y>::value) { if constexpr (pgsqL) { if (!*((char*)&t)) ov << '\'' << (def[0] ? def : "null") << "',"; else ov << '\'' << t << "',"; } else { if (!*((char*)&t)) ov << '\'' << (def[0] ? def : "0000-00-00 00:00:00") << "',"; else ov << '\'' << t << "',"; } } else if constexpr (std::is_same<std::string, Y>::value) { if (!*((char*)&t)) { ov << '\'' << toQuotes(def) << "',"; } else ov << '\'' << toQuotes(t.c_str()) << "',"; } else if constexpr (is_text<Y>::value) { if (!*((char*)&t)) { ov << '\'' << toQuotes(def) << "',"; } else ov << '\'' << toQuotes(t.c_str()) << "',"; } else { return; } } }); ov.seekp(-1, ov.cur); ov << "),"; } os << ')'; os << ' ' << ov.str(); os.seekp(-1, os.cur); os << ";"; D.conn()(os.str()).flush_results(); } template<typename T> template<typename U> Sql<T>& Sql<T>::innerJoin() { _.erase(static_cast<int>(T::_ios.size()), _.size()); for (int8_t i = -1; ++i < U::_len; f<U>(U::$[i])); _ += " FROM "; _ += T::_name; _ += T::_alias; _ += " INNER JOIN "; _ += U::_name; _ += U::_alias; _ += " ON "; F<T>(T::$[0]); _.push_back('='); F<U>(U::$[0]); return *this; } template<typename T> template<typename U, unsigned short I> Sql<T>& Sql<T>::innerJoin(const text<I>& v_) { _.erase(static_cast<int>(T::_ios.size()), _.size()); for (int8_t i = -1; ++i < U::_len; f<U>(U::$[i])); _ += " FROM "; _ += T::_name; _ += T::_alias; _ += " INNER JOIN "; _ += U::_name; _ += U::_alias; _ += " ON "; _ += v_.c_str(); return *this; } template<typename T> template<typename U> Sql<T>& Sql<T>::leftJoin() { _.erase(static_cast<int>(T::_ios.size()), _.size()); std::string* M = &RES_M_T[ObjLink<T, U>()]; for (int8_t i = -1; ++i < U::_len; f<U>(U::$[i])); _ += " FROM "; _ += T::_name; _ += T::_alias; _ += " LEFT JOIN "; _ += *M; _ += " ON "; _ += *M; _.push_back('.'); if constexpr (pgsqL) { _.push_back('"'); _ += T::_low; _.push_back('_'); _ += T::$[0]; _.push_back('"'); } else { _.push_back('`'); _ += T::_low; _.push_back('_'); _ += T::$[0]; _.push_back('`'); } _.push_back('='); F<T>(T::$[0]); _ += " LEFT JOIN "; _ += U::_name; _ += U::_alias; _ += " ON "; _ += *M; _.push_back('.'); M = nullptr; if constexpr (pgsqL) { _.push_back('"'); _ += U::_low; _.push_back('_'); _ += U::$[0]; _.push_back('"'); } else { _.push_back('`'); _ += U::_low; _.push_back('_'); _ += U::$[0]; _.push_back('`'); } _.push_back('='); F<U>(U::$[0]); return *this; } template<typename T> template<typename U, typename V> Sql<T>& Sql<T>::leftJoin() { _.erase(static_cast<int>(T::_ios.size()), _.size()); std::string* M = &RES_M_T[ObjLink<T, U>()], * N = &RES_M_T[ObjLink<U, V>()]; for (int8_t i = -1; ++i < U::_len; f<U>(U::$[i])); for (int8_t i = -1; ++i < V::_len; f<V>(V::$[i])); _ += " FROM "; _ += T::_name; _ += T::_alias; _ += " LEFT JOIN "; _ += *M; _ += " ON "; _ += *M; _.push_back('.'); if constexpr (pgsqL) { _.push_back('"'); _ += T::_low; _.push_back('_'); _ += T::$[0]; _.push_back('"'); } else { _.push_back('`'); _ += T::_low; _.push_back('_'); _ += T::$[0]; _.push_back('`'); } _.push_back('='); F<T>(T::$[0]); _ += " LEFT JOIN "; _ += U::_name; _ += U::_alias; _ += " ON "; _ += *M; _.push_back('.'); M = nullptr; if constexpr (pgsqL) { _.push_back('"'); _ += U::_low; _.push_back('_'); _ += U::$[0]; _.push_back('"'); } else { _.push_back('`'); _ += U::_low; _.push_back('_'); _ += U::$[0]; _.push_back('`'); } _.push_back('='); F<U>(U::$[0]); _ += " LEFT JOIN "; _ += *N; _ += " ON "; _ += *N; _.push_back('.'); if constexpr (pgsqL) { _.push_back('"'); _ += T::_low; _.push_back('_'); _ += T::$[0]; _.push_back('"'); } else { _.push_back('`'); _ += T::_low; _.push_back('_'); _ += T::$[0]; _.push_back('`'); } _.push_back('='); F<T>(T::$[0]); _ += " LEFT JOIN "; _ += V::_name; _ += V::_alias; _ += " ON "; _ += *N; _.push_back('.'); N = nullptr; if constexpr (pgsqL) { _.push_back('"'); _ += V::_low; _.push_back('_'); _ += V::$[0]; _.push_back('"'); } else { _.push_back('`'); _ += V::_low; _.push_back('_'); _ += V::$[0]; _.push_back('`'); } _.push_back('='); F<V>(V::$[0]); return *this; }}